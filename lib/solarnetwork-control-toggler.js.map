{"version":3,"file":"solarnetwork-control-toggler.js","sources":["../src/controlToggler.js"],"sourcesContent":["import { request as xhrRequest } from 'd3-request';\nimport { queue } from 'd3-queue';\nimport { \n\tAuthorizationV2Builder,\n\tdateParser,\n\tHttpContentType,\n\tHttpHeaders,\n\tHttpMethod,\n\tInstructionState,\n\tInstructionStates,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n } from 'solarnetwork-api-core';\n\nconst SetControlParameterInstructionName = 'SetControlParameter';\n\n/**\n * Instruction states that indicate a toggle instruction is in-flight.\n * @type {Set}\n * @private\n */\nconst InstructionActiveStates = new Set([\n\tInstructionStates.Queued,\n    InstructionStates.Received,\n\tInstructionStates.Executing\n]);\n\n/**\n * Instruction states that indicate a toggle instruction is comleted or declined.\n * @type {Set}\n * @private\n */\nconst InstructionFinishedStates = new Set([\n\tInstructionStates.Completed,\n\tInstructionStates.Declined,\n]);\n\n/**\n * @typedef {Object} ControlDatum\n * @property {string} created the datum date\n * @property {string} sourceId the control ID\n * @property {number} val the control value, essentially `0` or `1`\n */\n\n /**\n  * @typedef {Object} InstructionParameter\n  * @property {string} name the parameter name\n  * @property {string} value the parameter value\n  */\n\n /**\n  * @typedef {Object} Instruction\n  * @property {number} id the unique ID of the instruction\n  * @property {string} created the instruction date\n  * @property {string} status an `InstructionStatus` name value\n  * @property {InstructionParameter[]} [parameters] the instruction parameters\n  */\n\n/**\n * The status callback function.\n * \n * This function will be invoked whenever the control value has changed. Additionally, it will be\n * invoked periodically while a state change has not been completed, even if the control value\n * has not changed. Use {@link ControlToggler#value} to get the current control value and \n * {@link ControlToggler#hasPendingStateChange} to test if that value is still pending.\n * \n * @callback ControlToggler~statusCallback\n * @this ControlToggler\n * @param {Error} [error] an error if a failure occurred\n */\n\n/**\n * Manage the state of a boolean control switch using SolarNetwork `SetControlParameter` instructions.\n * \n * Use an instance of this class to keep track of, and update the state of, a single switch-like\n * control configured on a SolarNode. Because updating the state of a control is an asynchronous \n * process involving multiple steps, this class simplifies this with a simple callback API that\n * will be invoked whenever the control value changes.\n * \n * Once the {@link ControlToggler#start} method has been called, the toggler will make periodic\n * calls to SolarNetwork to get the most recent value for the configured control ID, which it\n * treats as a {@link ControlDatum} `sourceId` value. Thus if some other process changes the\n * control, the toggler will eventually pick up that change and invoke the callback function.\n * \n * @example\n * const urlHelper = new NodeInstructionUrlHelper();\n * urlHelper.nodeId = 123;\n * \n * const auth = new TestAuthBuilder('token');\n * auth.saveSigningKey('secret');\n * \n * const toggler = new ControlTogger(urlHelper, auth, '/power/switch/1');\n * toggler.callback = function(error) {\n *   // invoked when instruction states change, or the control value changes\n *   console.log(`Control ${toggler.controlId} value == ${toggler.value()}; pending == ${toggler.hasPendingStateChange}`);\n * };\n * \n * // enable automatic keeping track of state and the callback hook\n * toggler.start();\n * \n * // ... at some point later, maybe in response to a UI event, update the state;\n * // the callback will be invoked then the value changes\n * toggler.value(1);\n */\nclass ControlToggler {\n    /**\n     * Constructor.\n     * @param {NodeInstructionUrlHelper} urlHelper the URL helper to use, which must support node instructions with the `NodeInstructionUrlHelperMixin`\n     *                    and be configured with the `nodeId` property for the node to be managed\n\t * @param {AuthorizationV2Builder} authBuilder the auth builder to authenticate requests with; the required credentials\n\t *                                             must be set appropriately\n     * @param {string} controlId the ID of the control to manage\n\t * @param {NodeDatumUrlHelper} [queryUrlHelper] a URL helper for accessing node datum via SolarQuery; if not provided one\n\t *                                              will be created using the `environment` from `urlHelper`\n     */\n    constructor(urlHelper, authBuilder, controlId, queryUrlHelper) {\n\n        /**\n         * The URL helper to use, which must support node instructions with the `NodeInstructionUrlHelperMixin`\n         * and be configured with the `nodeId` property for the node to be managed.\n         * @type {NodeInstructionUrlHelper}\n         */\n\t\tthis.instructionUrlHelper = urlHelper;\n\t\t\n\t\t/**\n\t\t * The auth builder to use for authorizing requets. The credentials must be configured to support\n\t\t * posting instructions and viewing the data for the configured `controlId`.\n\t\t * @type {AuthorizationV2Builder}\n\t\t */\n\t\tthis.authBuilder = authBuilder || new AuthorizationV2Builder(null, urlHelper ? urlHelper.environment : undefined);\n\n        /**\n         * The control ID to manage.\n         * @type {string}\n         */\n\t\tthis.controlId = controlId;\n\t\t\n\t\t/**\n\t\t * The SolarQuery URL helper.\n\t\t * @type {NodeDatumUrlHelper}\n\t\t */\n\t\tthis.queryUrlHelper = (queryUrlHelper || new NodeDatumUrlHelper(urlHelper.environment));\n\n\t\t// force the nodeId / sourceId to our controlId\n\t\tthis.queryUrlHelper.nodeId = urlHelper.nodeId;\n\t\tthis.queryUrlHelper.sourceId = controlId;\n\n        /**\n         * A timer ID for refreshing the local state.\n         * @type {number}\n         * @private\n         */\n\t\tthis.timer = null;\n\t\t\n        /**\n         * The last known instruction status. The `val` property indicates the control value.\n         * @type {ControlDatum}\n         * @private\n         */\n        this.lastKnownDatum = undefined;\n\n        /**\n         * The last known instruction object.\n         * @type {Instruction}\n         * @private\n         */\n        this.lastKnownInstruction = undefined;\n\n        /**\n         * The refresh rate, in milliseconds.\n         * Defaults to 20 seconds.\n         * @type {number}\n         */\n        this.refreshMs = 20000;\n\n        /**\n         * The refresh rate, in milliseconds, when a toggle instruction is queued.\n         * Defaults to 5 seconds.\n         * @type {number}\n         */\n        this.pendingRefreshMs = 5000;\n\n        /**\n         * A callback function, which is called after the state of the control changes.\n         * The `this` reference will be set to this object. If an error has occurred,\n         * the error will be passed as the first argument.\n         * \n         * @type {function}\n         */\n        this.callback = undefined;\n    }\n\n\tnotifyDelegate(error) {\n        const callback = this.callback;\n\t\tif ( callback !== undefined ) {\n\t\t\ttry {\n\t\t\t\tcallback.call(self, error);\n\t\t\t} catch ( callbackError ) {\n\t\t\t\tlog.error('Error in callback: %s', callbackError);\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n     * Find an active `SetControlParameterInstruction` for the configured `controlId`.\n     * \n     * @param {Instruction[]} data array of instructions\n     * @returns {Instruction} the active instruction, or `undefined`\n     * @private\n     */\n    getActiveInstruction(data) {\n\t\tif ( !Array.isArray(data) || data.length === 0 ) {\n\t\t\treturn undefined;\n        }\n        const controlId = this.controlId;\n\t\tvar instruction = data.reduce((prev, curr) => {\n\t\t\tif ( curr.topic === SetControlParameterInstructionName && Array.isArray(curr.parameters)\n\t\t\t\t&& curr.parameters.length > 0 && curr.parameters[0].name === controlId\n\t\t\t\t&& (prev === undefined || prev.created < curr.created) ) {\n\t\t\t\treturn curr;\n\t\t\t}\n\t\t\treturn prev;\n\t\t}, undefined);\n\t\tif ( instruction !== undefined ) {\n\t\t\tlog.debug('Active instruction for %d found in state %s (set control %s to %s)', \n\t\t\t\tthis.instructionUrlHelper.nodeId, instruction.state, controlId, instruction.parameters[0].value);\n\t\t}\n\t\treturn instruction;\n\t}\n    \n    /**\n     * Get the last know instruction state, if available.\n     * @returns {InstructionState} the last known instruction state, or `undefined`\n     * @private\n     */\n\tlastKnownInstructionState() {\n        const lastKnownInstruction = this.lastKnownInstruction;\n\t\treturn (lastKnownInstruction === undefined ? undefined \n\t\t\t: InstructionState.valueOf(lastKnownInstruction.state));\n\t}\n    \n    /**\n     * Get the last known instruction value, e.g. the state of the control.\n     * @returns {number} the last know value of the control (0 or 1), or `undefined`\n     * @private\n     */\n\tlastKnownInstructionValue() {\n        const lastKnownInstruction = this.lastKnownInstruction;\n\t\treturn (lastKnownInstruction === undefined ? undefined \n\t\t\t: Number(lastKnownInstruction.parameters[0].value));\n\t}\n\n    /**\n     * Calculate the refresh rate to use.\n     * @returns {number} the refresh rate to use, in milliseconds\n     * @private\n     */\n\tcurrentRefreshMs() {\n        return (this.hasPendingStateChange\n\t\t\t? this.pendingRefreshMs\n\t\t\t: this.refreshMs);\n\t}\n\n\t/**\n\t * Test if a state change is pending confirmation.\n\t * \n\t * @returns {boolean} `true` if a state change is pending (not complete)\n\t */\n\tget hasPendingStateChange() {\n\t\treturn InstructionActiveStates.has(this.lastKnownInstructionState());\n\t}\n\t\n\t/**\n\t * Return the value from either the `controlStatus` or the first parameter value of an `instruction`,\n\t * whichever is valid and more recent.\n\t * \n\t * @param {ControlDatum} controlDatum a control status object\n\t * @param {Instruction} instruction  an instruction object\n\t * @returns {number} the control status value\n\t * @private\n\t */\n\tmostRecentValue(controlDatum, instruction) {\n\t\tif ( !instruction || InstructionStates.Declined.equals(instruction.status) ) {\n\t\t\treturn (controlDatum ? controlDatum.val : undefined);\n\t\t} else if ( !controlDatum ) {\n\t\t\treturn Number(instruction.parameters[0].value);\n\t\t}\n\t\t// return the newer value\n\t\tconst statusDate = dateParser(controlDatum.created);\n\t\tconst instructionDate = dateParser(instruction.created);\n\t\treturn (statusDate.getTime() > instructionDate.getTime() \n\t\t\t? controlDatum.val \n\t\t\t: Number(instruction.parameters[0].value));\n\t}\n\t\n\t/**\n\t * Handle the authentication for a request.\n\t * \n\t * <p>If the `url` contains query parameters and the `GET`` request is **not** used,\n\t * the `HttpContentType.FORM_URLENCODED` content type will be assumed.</p>\n\t * \n\t * @param {XMLHttpRequest} request the XHR\n\t * @param {string} method the HTTP method\n\t * @param {string} url the URL\n\t * @param {string} [contentType] a HTTP content type to use\n\t * @returns {void}\n\t * @private\n\t */\n\thandleRequestAuth(request, method, url, contentType) {\n\t\tconst now = new Date();\n\t\tthis.authBuilder.reset().date(now).snDate(true)\n\t\t\t.method(method)\n\t\t\t.url(url);\n\t\tif ( contentType ) {\n\t\t\tthis.authBuilder.contentType(contentType);\n\t\t}\n\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, this.authBuilder.requestDateHeaderValue);\n\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, this.authBuilder.buildWithSavedKey());\n\t}\n\n\t/**\n\t * Defer a JSON request on a queue.\n\t * \n\t * <p>If the `url` contains query parameters and the `GET`` method is **not** used,\n\t * the query parameters will be removed fom the URL and posted on the request body\n\t * instead, using the `HttpContentType.FORM_URLENCODED` content type.</p>\n\t * \n\t * @param {Queue} q the queue to defer with \n\t * @param {string} method the HTTP method\n\t * @param {string} url the URL\n\t * @returns {ControlToggler} this object\n\t * @private\n\t */\n\tdeferJsonRequestWithAuth(q, method, url) {\n\t\tlet queryIndex = -1;\n\t\tlet reqData = undefined;\n\t\tlet contentType = undefined;\n\t\tif ( method !== HttpMethod.GET ) {\n\t\t\tqueryIndex = url.indexOf('?');\n\t\t\treqData = url.substring(queryIndex + 1);\n\t\t\tcontentType = HttpContentType.FORM_URLENCODED_UTF8;\n\t\t}\n\t\tconst req = xhrRequest(queryIndex >= 0 ? url.substring(0, queryIndex) : url)\n\t\t\t.mimeType(HttpContentType.APPLICATION_JSON)\n\t\t\t.on('beforesend', (request) => {\n\t\t\t\tthis.handleRequestAuth(request, method, url, contentType);\n\t\t\t});\n\t\tif ( contentType ) {\n\t\t\treq.header('Content-Type', contentType);\n\t\t}\n\t\tq.defer(req.send, method, reqData);\n\t\treturn this;\n\t}\n    \n\t/**\n\t * Get or set the desired control value.\n\t * \n\t * @param {number} [desiredValue] the control value to set\n\t * @returns {number|ControlToggler} when called as a getter, the last known control value; when called as a\n\t *                                  setter, this object\n\t */\n\tvalue(desiredValue) {\n\t\tif ( !arguments.length ) return (this.lastKnownDatum === undefined ? undefined : this.lastKnownDatum.val);\n\t\tif ( !this.authBuilder.signingKeyValid ) {\n\t\t\tthrow new Error('Valid credentials not configured');\n\t\t}\n        const controlId = this.controlId;\n\t\tconst instrUrlHelper = this.instructionUrlHelper;\n\t\tconst q = queue();\n\t\tvar currentValue = (this.lastKnownDatum === undefined ? undefined : this.lastKnownDatum.val);\n\t\tvar pendingState = this.lastKnownInstructionState();\n\t\tvar pendingValue = this.lastKnownInstructionValue();\n\t\tif ( pendingState === InstructionStates.Queued && pendingValue !== desiredValue ) {\n\t\t\t// cancel the pending instruction\n\t\t\tlog.debug('Canceling %d pending control %s switch to %s', instrUrlHelper.nodeId, controlId,  pendingValue);\n            const cancelInstructionUrl = instrUrlHelper.updateInstructionStateUrl(\n\t\t\t\tthis.lastKnownInstruction.id, InstructionStates.Declined);\n\t\t\tthis.deferJsonRequestWithAuth(q, HttpMethod.POST, cancelInstructionUrl);\n\t\t\tthis.lastKnownInstruction = undefined;\n\t\t\tpendingState = undefined;\n\t\t\tpendingValue = undefined;\n\t\t}\n\t\tif ( currentValue !== desiredValue && pendingValue !== desiredValue ) {\n\t\t\tlog.debug('Request %d to change control %s to %d',  instrUrlHelper.nodeId, controlId, desiredValue);\n            const queueInstructionUrl = instrUrlHelper.queueInstructionUrl(SetControlParameterInstructionName, [\n\t\t\t\t{name: controlId, value: String(desiredValue)}\n\t\t\t]);\n\t\t\tthis.deferJsonRequestWithAuth(q, HttpMethod.POST, queueInstructionUrl);\n\t\t}\n\t\tq.awaitAll((error, results) => {\n\t\t\tif ( error ) {\n\t\t\t\tlog.error('Error updating %d control toggler %s: %s', instrUrlHelper.nodeId, controlId, error.status);\n\t\t\t\tthis.notifyDelegate(error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( results.length < 1 ) {\n\t\t\t\t// we queued nothing\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresults.forEach((e, i) => {\n\t\t\t\tif ( e.responseText ) {\n\t\t\t\t\tresults[i] = JSON.parse(e.responseText);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst cancelResult =results[0];\n\t\t\t// note == null check here, which handles either undefined or null\n\t\t\tif ( cancelResult.data == null && cancelResult.success === true ) {\n\t\t\t\t// it was cancelled\n\t\t\t\tthis.lastKnownInstruction = undefined;\n\t\t\t}\n\t\t\tconst instructionResult = results[results.length - 1].data;\n\t\t\tif ( !(instructionResult == null) ) {\n\t\t\t\t// this is the last know instruction now\n\t\t\t\tthis.lastKnownInstruction = instructionResult;\n\t\t\t}\n\t\t\t\n\t\t\t// invoke the client callback so they know the instruction state has changed\n\t\t\tthis.notifyDelegate();\n\t\t\t\n\t\t\t// reset timer to start polling at pendingRefreshMs rate\n\t\t\tif ( this.timer ) {\n\t\t\t\tthis.stop();\n\t\t\t\tthis.start(this.currentRefreshMs());\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\t\n    /**\n     * Refresh the control state from SolarNetwork.\n\t * \n\t * Once the {@link ControlToggler#start} method is called, this method is invoked periodically\n\t * automatically. Only call this directly if you need to manually update the state of the control.\n\t * \n     * @returns {ControlToggler} this object\n     */\n\tupdate() {\n\t\tif ( !this.authBuilder.signingKeyValid ) {\n\t\t\tthrow new Error('Valid credentials not configured');\n\t\t}\n\t\tconst controlId = this.controlId;\n\t\tconst instrUrlHelper = this.instructionUrlHelper;\n\t\tconst queryUrlHelper = this.queryUrlHelper;\n\t\tconst q = queue();\n\n\t\t// query for most recently available datum for control to check control value\n\t\tconst mostRecentUrl = queryUrlHelper.mostRecentDatumUrl();\n\t\tthis.deferJsonRequestWithAuth(q, HttpMethod.GET, mostRecentUrl);\n\n\t\t// query for pending instructions to see if we have an in-flight SetControlParameter on the go already\n\t\tconst viewPendingUrl = instrUrlHelper.viewPendingInstructionsUrl();\n\t\tthis.deferJsonRequestWithAuth(q, HttpMethod.GET, viewPendingUrl);\n\n\t\tif ( this.lastKnownInstruction && !InstructionFinishedStates.has(this.lastKnownInstructionState()) ) {\n\t\t\t// also refresh this specific instruction, to know when it goes to Completed so we can\n\t\t\t// assume the control value has changed, even if the mostRecent data lags behind\n\t\t\tconst viewInstructionUrl = instrUrlHelper.viewInstructionUrl(this.lastKnownInstruction.id);\n\t\t\tthis.deferJsonRequestWithAuth(q, HttpMethod.GET, viewInstructionUrl);\n\t\t}\n\n\t\tq.awaitAll((error, results) => {\n\t\t\tif ( error ) {\n\t\t\t\tlog.error('Error querying %d control toggler %s status: %s', instrUrlHelper.nodeId, controlId, error.status);\n\t\t\t\tthis.notifyDelegate(error);\n\t\t\t} else {\n\t\t\t\tresults.forEach((e, i) => {\n\t\t\t\t\tif ( e.responseText ) {\n\t\t\t\t\t\tresults[i] = JSON.parse(e.responseText);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet mostRecentDatum, active, executing;\n\t\t\t\tif ( results.length > 0 ) {\n\t\t\t\t\tmostRecentDatum = results[0];\n\t\t\t\t}\n\t\t\t\tif ( results.length > 1 ) {\n\t\t\t\t\tactive = results[1];\n\t\t\t\t}\n\t\t\t\tif ( results.length > 2 ) {\n\t\t\t\t\texecuting = results[2];\n\t\t\t\t}\n\t\t\t\t// get current status of control via most recent datum\n\t\t\t\t/** @type {ControlDatum} */\n\t\t\t\tlet mostRecentControlDatum = undefined;\n\t\t\t\tif ( mostRecentDatum.data && Array.isArray(mostRecentDatum.data.results) ) {\n\t\t\t\t\tmostRecentControlDatum = mostRecentDatum.data.results.find((e) => e.sourceId === controlId);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// get active (pending) instruction (if any)\n\t\t\t\tconst execInstruction = (executing ? executing.data : undefined);\n\t\t\t\tconst pendingInstruction = (active ? this.getActiveInstruction(active.data) : undefined);\n\t\t\t\tconst newValue = (this.mostRecentValue(mostRecentControlDatum, execInstruction ? execInstruction \n\t\t\t\t\t\t\t\t: pendingInstruction ? pendingInstruction : this.lastKnownInstruction));\n\t\t\t\tconst currValue = this.value();\n\t\t\t\tif ( newValue !== currValue ) {\n\t\t\t\t\tlog.debug('Current %d control %s value is %s',  instrUrlHelper.nodeId, controlId, (newValue !== undefined ? newValue : 'N/A'));\n\t\t\t\t\tthis.lastKnownDatum = mostRecentControlDatum;\n\t\t\t\t\tif ( this.lastKnownDatum && !pendingInstruction ) {\n\t\t\t\t\t\tthis.lastKnownDatum.val = newValue; // force this, because instruction value might be newer than status value\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastKnownInstruction = (execInstruction ? execInstruction : pendingInstruction);\n\t\t\t\t\t\n\t\t\t\t\t// invoke the client callback so they know the data has been updated\n\t\t\t\t\tthis.notifyDelegate();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if timer was defined, keep going as if interval set\n\t\t\tif ( this.timer !== undefined ) {\n\t\t\t\tthis.timer = setTimeout(() => {\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t}, this.currentRefreshMs());\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start automatically updating the status of the configured control.\n\t * \n\t * @param {number} [when=20] an optional offset in milliseconds to start at\n\t * @returns {ControlToggler} this object\n\t */\n\tstart(when) {\n        const timer = this.timer;\n\t\tif ( !timer ) {\n\t\t\tthis.timer = setTimeout(() => {\n\t\t\t\t\tthis.update();\n\t\t\t\t}, (when || 20));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Stop automatically updating the status of the configured control.\n\t * \n\t * @returns {ControlToggler} this object\n\t */\n\tstop() {\n        const timer = this.timer;\n\t\tif ( timer ) {\n\t\t\tclearTimeout(timer);\n\t\t\tthis.timer = null;\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport default ControlToggler;\n"],"names":["SetControlParameterInstructionName","InstructionActiveStates","Set","InstructionStates","Queued","Received","Executing","InstructionFinishedStates","Completed","Declined","ControlToggler","urlHelper","authBuilder","controlId","queryUrlHelper","instructionUrlHelper","AuthorizationV2Builder","environment","undefined","NodeDatumUrlHelper","nodeId","sourceId","timer","lastKnownDatum","lastKnownInstruction","refreshMs","pendingRefreshMs","callback","error","call","self","callbackError","data","Array","isArray","length","instruction","reduce","prev","curr","topic","parameters","name","created","debug","state","value","InstructionState","valueOf","Number","hasPendingStateChange","controlDatum","equals","status","val","statusDate","dateParser","instructionDate","getTime","request","method","url","contentType","now","Date","reset","date","snDate","setRequestHeader","HttpHeaders","X_SN_DATE","requestDateHeaderValue","AUTHORIZATION","buildWithSavedKey","q","queryIndex","reqData","HttpMethod","GET","indexOf","substring","HttpContentType","FORM_URLENCODED_UTF8","req","xhrRequest","mimeType","APPLICATION_JSON","on","handleRequestAuth","header","defer","send","desiredValue","arguments","signingKeyValid","Error","instrUrlHelper","queue","currentValue","pendingState","lastKnownInstructionState","pendingValue","lastKnownInstructionValue","cancelInstructionUrl","updateInstructionStateUrl","id","deferJsonRequestWithAuth","POST","queueInstructionUrl","String","awaitAll","results","notifyDelegate","forEach","e","i","responseText","JSON","parse","cancelResult","success","instructionResult","stop","start","currentRefreshMs","mostRecentUrl","mostRecentDatumUrl","viewPendingUrl","viewPendingInstructionsUrl","has","viewInstructionUrl","mostRecentDatum","active","executing","mostRecentControlDatum","find","execInstruction","pendingInstruction","getActiveInstruction","newValue","mostRecentValue","currValue","setTimeout","update","when"],"mappings":"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"}